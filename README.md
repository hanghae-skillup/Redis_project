# Redis_project

## Multi Module Role
### multi-movie-service (PORT: 8081)
- 현재 상영중인 영화를 보여주는 **메인 서비스**입니다.
- 해당 모듈에 DB가 연결되어 있고, DB의 ORM은 해당 서비스에서 관리합니다.
- 1,2주차 구현의 API 컨트롤러가 해당 모듈에 구현되어 있습니다.
### multi-theaterEntity-service (PORT: 8082)
- 상영관을 관리하는 서비스입니다.
- 상영관을 등록하고 조회하며, 좌석(Seat) 관리의 역할을 가지고 있습니다.
### multi-booking-service (PORT: 8083)
- 영화 예약을 담당하는 서비스입니다.
- 현재 상영(Screening)에 대한 좌석 예매하며, 중복 예매 방지, 예매 정보(고객 이름, 전화번호)를 저장합니다.
---
## Table Design
- Movies (영화 정보 저장)
    - rating: 영화 관람등급 (ALL, TWELVE, FIFTEEN, ADULT)
    - genres: 영화 장르
    - duration: 상영시간(단위: 분)
- Theaters
    - 상영관 정보
- Seats
    - 상영관 좌석 정보
    - 5x5 형태의 좌석 구조 (A1-E5)
    - theater_id로 어떤 상영관의 좌석인지 구분
- Screenings
    - 영화 상영 일정 (현재 예약 가능한 영화)
    - movie_id와 theater_id로 어떤 영화가 어느 상영관에서 상영되는지 구분
- Reservations
    - 예매 정보
    - screening_id로 어떤 상영에 대한 예매인지 구분
    - seat_id로 어떤 좌석이 예매되었는지 구분
    - customer_name과 phone_number로 예매자 정보 관리
- Notes
    - 모든 테이블은 생성일자(created_at)와 수정일자(updated_at) 포함
    - 외래키 제약조건을 통해 데이터 정합성 보장
    - 인덱스는 기본키(PK)만 사용
---
# Test summary
## 1. 캐싱 데이터 설계
### 1.1 캐싱 대상 데이터
- 메인 페이지의 전체 영화 목록
    - 조회가 자주 발생하며, 데이터 변경이 자주 일어나지 않기 때문
- 장르별 필터링된 영화 목록
  - 사용자들이 특정 장르를 자주 검색할 것으로 예상
### 1.2 캐시 정책
- Cache-Aside 패턴 적용
- TTL(Time To Live): 1시간
- 캐시 키 패턴:
  - 기본 프리픽스: ```movies::search::```
  - 전체 목록: ```movies::search::all```
  - 제목 검색: ```movies::search::title::{searchTerm}```
  - 장르 검색: ```movies::search::genres::{genreName}```
  - 제목+장르 검색: ```movies::search::title::{searchTerm}::genres::{genreName}```

## 2. 테스트 환경 설정
### 2.1 테스트 데이터
- 총 영화 데이터: 500개
- 장르 분포: 10개 장르, 각 50개 영화
- 데이터 구조:
```json
Movie {
  title: String (평균 30자)
  rating: String (5자)
  releaseDate: Date
  thumbnailUrl: String (100자)
  duration: Integer
  genre: String (10자)
}
```
- 예상 데이터 크기: ~100KB/건 × 500건 = ```~50MB```

### 2.2 성능 목표

1. Throughput
   - 목표 RPS: 5,000 (피크 시간)
   - 평균 RPS: 500

2. Latency
   - p95 < 3,000ms (3초)
   - p99 < 5,000ms (5초)
   - 평균 응답시간 < 2,000ms (2초)

3. Error Rate
   - 전체 오류율 < 1%
   - 시스템 오류 (5xx) < 0.1%

4. Sort Validation
   - 정렬 성공률 > 95%

5. Memory Usage
   - 최대 메모리: 2GB 미만
   - 평균 메모리: 1GB 미만
   - RSS 메모리(p95): 1.5GB 미만

6. 부하 조건
   - 지속 시간: 10분
   - 단계별 부하:
     - 램프 업: 2분
     - 피크 부하: 5분
     - 램프 다운: 3분

## 3. 단계별 테스트 계획
### 3.1 검색 기능 추가 후 (Indexing 적용 전)
```sql
SELECT m.title, m.rating, m.release_date, m.thumbnail_url, m.duration, m.genre
FROM movies m
WHERE m.title LIKE :searchTerm
ORDER BY m.release_date DESC
```

### 3.2 Indexing 적용 
```mysql
CREATE INDEX idx_movies_title ON movies (title);
CREATE INDEX idx_movies_release_date ON movies (release_date);
CREATE INDEX idx_movies_genre ON movies (genre);
```

### 3.3 Caching 적용
```JAVA
@Cacheable(value = "movieSearch", key = "#searchTerm")
public List<MovieProjection> searchMovies(String searchTerm) {
    // 로직
}
```

## 4. 테스트 시나리오
### 4.1 K6 테스트 스크립트
`여기에 테스트 스크립트 파일 링크`
### 4.2 모니터링 지표

- 응답 시간 (Response Time)
  - 평균, p95, p99
- 처리량 (Throughput)
  - 초당 요청 수 (RPS)
- 오류율 (Error Rate)
  - 5xx, 4xx 응답 비율
- 리소스 사용률
  - CPU 사용률
  - 메모리 사용률
  - DB 연결 수

## 5. 결과 수집 및 분석 방법
### 5.1 수집할 메트릭
- JVM 메트릭
  - GC 시간
  - 힙 메모리 사용량
- 데이터베이스 메트릭
  - Query 실행 시간
  - Connection Pool 상태
- Redis 메트릭
  - Hit/Miss 비율
  - 메모리 사용량

### 5.2 분석 기준
1. 응답 시간 분포 
2. 초당 처리 요청 수 
3. 캐시 히트율 
4. DB Connection 사용률 
5. 시스템 리소스 사용률

## 6. 테스트 결과
### 6-1. 인덱싱 적용 전

- 테스트 단계: 인덱싱 적용 전
- 실행 일시: 2024-12-15 23:30
- 테스트 기간: 10분

1. 성능 지표 
   - 평균 응답시간: 6.13초
   - p95 응답시간: 14.62초
   - p90 응답시간: 13.27초
   - 최대 RPS: 333.12
   - 오류율: 0%


2. 리소스 사용률
   - 수신된 데이터: 12 GB (19 MB/s)
   - 전송된 데이터: 22 MB (37 kB/s)
   - HTTP 요청 처리 시간:
     - 연결 설정: 평균 174.69µs
     - 대기 시간: 평균 6.13초
     - 수신 시간: 평균 1.57ms
     - 전송 시간: 평균 357.65µs
   - 메모리 사용량:
       - 총 메모리: 679.70 MB
       - 사용된 메모리: 315.13 MB


3. 성능 체크 결과
   - 전체 체크 성공률: 83.25% (499,965 / 600,504)
   - API 응답 성공률: 100% (오류율 0%)
   - 응답시간 < 3초: 약 49% (searchMovies), 50% (getCurrentMovies)
   - 정렬 검증 성공률: 100% (sort_validation_rate=100%)


### 분석
- Throughput
  - 목표 RPS(5,000)의 6.6%인 333.12 RPS만 처리 가능
  - 높은 부하 상황에서 서버가 요청을 효과적으로 처리하지 못함
- Latency
  - 평균 응답 시간이 6.13초로 매우 느림
  - p95가 14.62초로 목표(200ms)보다 73배 이상 느림
  - p90이 13.27초로 매우 높음
  - 최대 응답 시간이 26.73초로 매우 높음
- Sort
  - 전체 정렬 검증 성공률 100% (정렬 문제 없음)
- 리소스 사용
  - 데이터 수신량이 12GB로 매우 높음
  - 전송된 데이터 22MB로 과도한 데이터 전송 발생
  - HTTP 요청 대기 시간이 평균 6.13초로 비효율적인 DB 쿼리 처리 가능성
  - 메모리 사용량: 총 679.70MB 중 315.13MB 사용 (정상 범위)
  - HTTP 연결 설정 시간 평균 174.69µs로 양호
---
### 6-2. 인덱싱 적용 후, 캐싱 적용 전
- 테스트 단계: 인덱싱 적용 후, 캐싱 적용 전
- 실행 일시: 2024-12-15 01:20
- 테스트 기간: 10분

1. 성능 지표
   - 평균 응답시간: 10.99초
   - p95 응답시간: 26.29초
   - p90 응답시간: 24.00초
   - 최대 응답시간: 43.46초
   - 최대 RPS: 200.76 RPS
   - 오류율: 0%


2. 리소스 사용률
   - 수신된 데이터: 6.9 GB (12 MB/s)
   - 전송된 데이터: 13 MB (22 kB/s)
   - HTTP 요청 처리 시간:
       - 연결 설정: 평균 706.01µs
       - 대기 시간: 평균 10.99초
       - 수신 시간: 평균 3.9ms
       - 전송 시간: 평균 1.22ms
   - 메모리 사용량:
       - 총 메모리: 698.04 MB
       - 사용된 메모리: 316.57 MB

3. 성능 체크 결과
 - 전체 체크 성공률: 77.91% (282,036 / 361,992)
 - API 응답 성공률: 100% (오류율 0%)
 - 응답시간 < 3초: 약 33% (searchMovies), 33% (getCurrentMovies)
 - 정렬 검증 성공률: 100% (sort_validation_rate=100%)

### 분석

1. Throughput
   - 목표 RPS(5,000)의 4%인 200.76 RPS 처리 가능
   - 높은 부하 상황에서 서버가 요청을 효과적으로 처리하지 못함

2. Latency 
   - 평균 응답 시간이 10.99초로 느림
   - p95가 26.29초로 목표(200ms)보다 131배 이상 느림
   - p90이 24.00초로 매우 높음
   - 최대 응답 시간이 43.46초로 극단적으로 높음

3. sorted
   - 정렬 검증 성공률 100% (정렬 문제 없음)

4. 리소스 사용 
   - 데이터 수신량은 6.9GB로 6-1보다는 낮아졌지만 여전히 높음
   - 전송된 데이터 13MB로 6-1에 비해 40.9% 감소
   - HTTP 요청 대기 시간이 평균 10.99초로 비효율적인 DB 쿼리 처리 가능성
   - 메모리 사용량: 총 698.04MB 중 316.57MB 사용 (정상 범위)
   - HTTP 연결 설정 시간 평균 706.01µs로 양호

---

### 6-3. 인덱싱과 캐싱 적용 후

- 테스트 단계: 인덱싱 적용 후, 캐싱 적용 전
- 실행 일시: 2024-12-15 02:00
- 테스트 기간: 10분

1. 성능 지표
   - 평균 응답시간: 6.32초
   - p95 응답시간: 15.52초
   - p90 응답시간: 14.37초
   - 최대 응답시간: 25.96초
   - 최대 RPS: 322.81 RPS
   - 오류율: 0%

2. 리소스 사용률
   - 수신된 데이터: 11 GB (19 MB/s)
   - 전송된 데이터: 21 MB (36 kB/s)
   - HTTP 요청 처리 시간:
       - 연결 설정: 평균 687.98µs
       - 대기 시간: 평균 6.31초
       - 수신 시간: 평균 4.14ms
       - 전송 시간: 평균 1.36ms
   - 메모리 사용량:
       - 총 메모리: 864.02 MB
       - 사용된 메모리: 377.88 MB

3. 성능 체크 결과
   - 전체 체크 성공률: 82.67% (480,976 / 581,796)
   - API 응답 성공률: 100% (오류율 0%)
   - 응답시간 < 3초: 약 47% (searchMovies), 48% (getCurrentMovies)
   - 정렬 검증 성공률: 100%

### 분석

1. Throughput 개선
   - RPS가 200.76에서 322.81로 60.8% 증가
   - 목표 RPS(5,000) 대비 6.4%로 소폭 상승했으나 여전히 낮음
   - 동시 처리 능력이 개선되었으나 추가 최적화 필요

2. Latency 개선
   - 평균 응답 시간 42.5% 감소 (10.99초 → 6.32초)
   - p95 41% 개선 (26.29초 → 15.52초)
   - p90 40.1% 개선 (24.00초 → 14.37초)
   - 최대 응답 시간 40.3% 감소 (43.46초 → 25.96초)

3. 정확성 및 안정성
   - 정렬 검증 성공률 100% 유지
   - 전체 체크 성공률 4.76% 증가 (77.91% → 82.67%)
   - 3초 이내 응답 비율 14% 향상 (33% → 47%)

4. 리소스 활용도
   - 데이터 처리량 59.4% 증가 (6.9GB → 11GB)
   - 대기 시간 42.6% 감소 (10.99초 → 6.31초)
   - 메모리 사용량 19.4% 증가 (총 메모리 698.04MB → 864.02MB)
   - 연결 설정 시간 2.6% 개선 (706.01µs → 687.98µs)

